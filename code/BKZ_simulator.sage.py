

# This file was *autogenerated* from the file BKZ_simulator.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1p = RealNumber('1.'); _sage_const_2p = RealNumber('2.'); _sage_const_0 = Integer(0); _sage_const_1e20 = RealNumber('1e20'); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_1p021900 = RealNumber('1.021900'); _sage_const_3 = Integer(3); _sage_const_1p020807 = RealNumber('1.020807'); _sage_const_4 = Integer(4); _sage_const_1p019713 = RealNumber('1.019713'); _sage_const_5 = Integer(5); _sage_const_1p018620 = RealNumber('1.018620'); _sage_const_6 = Integer(6); _sage_const_1p018128 = RealNumber('1.018128'); _sage_const_7 = Integer(7); _sage_const_1p017636 = RealNumber('1.017636'); _sage_const_8 = Integer(8); _sage_const_1p017144 = RealNumber('1.017144'); _sage_const_9 = Integer(9); _sage_const_1p016652 = RealNumber('1.016652'); _sage_const_10 = Integer(10); _sage_const_1p016160 = RealNumber('1.016160'); _sage_const_11 = Integer(11); _sage_const_1p015898 = RealNumber('1.015898'); _sage_const_12 = Integer(12); _sage_const_1p015636 = RealNumber('1.015636'); _sage_const_13 = Integer(13); _sage_const_1p015374 = RealNumber('1.015374'); _sage_const_14 = Integer(14); _sage_const_1p015112 = RealNumber('1.015112'); _sage_const_15 = Integer(15); _sage_const_1p014850 = RealNumber('1.014850'); _sage_const_16 = Integer(16); _sage_const_1p014720 = RealNumber('1.014720'); _sage_const_17 = Integer(17); _sage_const_1p014590 = RealNumber('1.014590'); _sage_const_18 = Integer(18); _sage_const_1p014460 = RealNumber('1.014460'); _sage_const_19 = Integer(19); _sage_const_1p014330 = RealNumber('1.014330'); _sage_const_20 = Integer(20); _sage_const_1p014200 = RealNumber('1.014200'); _sage_const_21 = Integer(21); _sage_const_1p014044 = RealNumber('1.014044'); _sage_const_22 = Integer(22); _sage_const_1p013888 = RealNumber('1.013888'); _sage_const_23 = Integer(23); _sage_const_1p013732 = RealNumber('1.013732'); _sage_const_24 = Integer(24); _sage_const_1p013576 = RealNumber('1.013576'); _sage_const_25 = Integer(25); _sage_const_1p013420 = RealNumber('1.013420'); _sage_const_26 = Integer(26); _sage_const_1p013383 = RealNumber('1.013383'); _sage_const_27 = Integer(27); _sage_const_1p013347 = RealNumber('1.013347'); _sage_const_28 = Integer(28); _sage_const_1p013310 = RealNumber('1.013310'); _sage_const_29 = Integer(29); _sage_const_1p013253 = RealNumber('1.013253'); _sage_const_30 = Integer(30); _sage_const_1p013197 = RealNumber('1.013197'); _sage_const_31 = Integer(31); _sage_const_1p013140 = RealNumber('1.013140'); _sage_const_32 = Integer(32); _sage_const_1p013084 = RealNumber('1.013084'); _sage_const_33 = Integer(33); _sage_const_1p013027 = RealNumber('1.013027'); _sage_const_34 = Integer(34); _sage_const_1p012970 = RealNumber('1.012970'); _sage_const_35 = Integer(35); _sage_const_1p012914 = RealNumber('1.012914'); _sage_const_36 = Integer(36); _sage_const_1p012857 = RealNumber('1.012857'); _sage_const_37 = Integer(37); _sage_const_1p012801 = RealNumber('1.012801'); _sage_const_38 = Integer(38); _sage_const_1p012744 = RealNumber('1.012744'); _sage_const_39 = Integer(39); _sage_const_1p012687 = RealNumber('1.012687'); _sage_const_40 = Integer(40); _sage_const_1p012631 = RealNumber('1.012631'); _sage_const_41 = Integer(41); _sage_const_1p012574 = RealNumber('1.012574'); _sage_const_42 = Integer(42); _sage_const_1p012518 = RealNumber('1.012518'); _sage_const_43 = Integer(43); _sage_const_1p012461 = RealNumber('1.012461'); _sage_const_44 = Integer(44); _sage_const_1p012404 = RealNumber('1.012404'); _sage_const_45 = Integer(45); _sage_const_1p012348 = RealNumber('1.012348'); _sage_const_46 = Integer(46); _sage_const_1p012291 = RealNumber('1.012291'); _sage_const_47 = Integer(47); _sage_const_1p012235 = RealNumber('1.012235'); _sage_const_48 = Integer(48); _sage_const_1p012178 = RealNumber('1.012178'); _sage_const_49 = Integer(49); _sage_const_1p012121 = RealNumber('1.012121'); _sage_const_50 = Integer(50); _sage_const_1p012065 = RealNumber('1.012065'); _sage_const_0p789527997160000 = RealNumber('0.789527997160000'); _sage_const_0p780003183804613 = RealNumber('0.780003183804613'); _sage_const_0p750872218594458 = RealNumber('0.750872218594458'); _sage_const_0p706520454592593 = RealNumber('0.706520454592593'); _sage_const_0p696345241018901 = RealNumber('0.696345241018901'); _sage_const_0p660533841808400 = RealNumber('0.660533841808400'); _sage_const_0p626274718790505 = RealNumber('0.626274718790505'); _sage_const_0p581480717333169 = RealNumber('0.581480717333169'); _sage_const_0p553171463433503 = RealNumber('0.553171463433503'); _sage_const_0p520811087419712 = RealNumber('0.520811087419712'); _sage_const_0p487994338534253 = RealNumber('0.487994338534253'); _sage_const_0p459541470573431 = RealNumber('0.459541470573431'); _sage_const_0p414638319529319 = RealNumber('0.414638319529319'); _sage_const_0p392811729940846 = RealNumber('0.392811729940846'); _sage_const_0p339090376264829 = RealNumber('0.339090376264829'); _sage_const_0p306561491936042 = RealNumber('0.306561491936042'); _sage_const_0p276041187709516 = RealNumber('0.276041187709516'); _sage_const_0p236698863270441 = RealNumber('0.236698863270441'); _sage_const_0p196186341673080 = RealNumber('0.196186341673080'); _sage_const_0p161214212092249 = RealNumber('0.161214212092249'); _sage_const_0p110895134828114 = RealNumber('0.110895134828114'); _sage_const_0p0678261623920553 = RealNumber('0.0678261623920553'); _sage_const_0p0272807162335610 = RealNumber('0.0272807162335610'); _sage_const_0p0234609979600137 = RealNumber('0.0234609979600137'); _sage_const_0p0320527224746912 = RealNumber('0.0320527224746912'); _sage_const_0p0940331032784437 = RealNumber('0.0940331032784437'); _sage_const_0p129109087817554 = RealNumber('0.129109087817554'); _sage_const_0p176965384290173 = RealNumber('0.176965384290173'); _sage_const_0p209405754915959 = RealNumber('0.209405754915959'); _sage_const_0p265867993276493 = RealNumber('0.265867993276493'); _sage_const_0p299031324494802 = RealNumber('0.299031324494802'); _sage_const_0p349338597048432 = RealNumber('0.349338597048432'); _sage_const_0p380428160303508 = RealNumber('0.380428160303508'); _sage_const_0p427399405474537 = RealNumber('0.427399405474537'); _sage_const_0p474944677694975 = RealNumber('0.474944677694975'); _sage_const_0p530140672818150 = RealNumber('0.530140672818150'); _sage_const_0p561625221138784 = RealNumber('0.561625221138784'); _sage_const_0p612008793872032 = RealNumber('0.612008793872032'); _sage_const_0p669011014635905 = RealNumber('0.669011014635905'); _sage_const_0p713766731570930 = RealNumber('0.713766731570930'); _sage_const_0p754041787011810 = RealNumber('0.754041787011810'); _sage_const_0p808609696192079 = RealNumber('0.808609696192079'); _sage_const_0p859933249032210 = RealNumber('0.859933249032210'); _sage_const_0p884479963601658 = RealNumber('0.884479963601658'); _sage_const_0p886666930030433 = RealNumber('0.886666930030433'); _sage_const_p5 = RealNumber('.5'); _sage_const_1500 = Integer(1500); _sage_const_1000 = Integer(1000); _sage_const_2049 = Integer(2049); _sage_const_0p = RealNumber('0.'); _sage_const_p001 = RealNumber('.001'); _sage_const_p01 = RealNumber('.01')# This file is an excerpt from the Leaky-LWE estimator, with minor tweaks

from math import exp
from sage.all import e, floor, log, pi, RR, copy, vector, RealDistribution,         ceil, sqrt


def GH_sv_factor_squared(k):
    return ((pi * k)**(_sage_const_1p  / k) * k / (_sage_const_2p  * pi * e))


def compute_delta(k):
    """Computes delta from the block size k. Interpolation from the following
    data table:
    Source : https://bitbucket.org/malb/lwe-estimator/
    src/9302d4204b4f4f8ceec521231c4ca62027596337/estima
    tor.py?at=master&fileviewer=file-view-default
    :k: integer
    estimator.py table:
    """

    small = {_sage_const_0 : _sage_const_1e20 , _sage_const_1 : _sage_const_1e20 , _sage_const_2 : _sage_const_1p021900 , _sage_const_3 : _sage_const_1p020807 , _sage_const_4 : _sage_const_1p019713 , _sage_const_5 : _sage_const_1p018620 ,
             _sage_const_6 : _sage_const_1p018128 , _sage_const_7 : _sage_const_1p017636 , _sage_const_8 : _sage_const_1p017144 , _sage_const_9 : _sage_const_1p016652 , _sage_const_10 : _sage_const_1p016160 ,
             _sage_const_11 : _sage_const_1p015898 , _sage_const_12 : _sage_const_1p015636 , _sage_const_13 : _sage_const_1p015374 , _sage_const_14 : _sage_const_1p015112 , _sage_const_15 : _sage_const_1p014850 ,
             _sage_const_16 : _sage_const_1p014720 , _sage_const_17 : _sage_const_1p014590 , _sage_const_18 : _sage_const_1p014460 , _sage_const_19 : _sage_const_1p014330 , _sage_const_20 : _sage_const_1p014200 ,
             _sage_const_21 : _sage_const_1p014044 , _sage_const_22 : _sage_const_1p013888 , _sage_const_23 : _sage_const_1p013732 , _sage_const_24 : _sage_const_1p013576 , _sage_const_25 : _sage_const_1p013420 ,
             _sage_const_26 : _sage_const_1p013383 , _sage_const_27 : _sage_const_1p013347 , _sage_const_28 : _sage_const_1p013310 , _sage_const_29 : _sage_const_1p013253 , _sage_const_30 : _sage_const_1p013197 ,
             _sage_const_31 : _sage_const_1p013140 , _sage_const_32 : _sage_const_1p013084 , _sage_const_33 : _sage_const_1p013027 , _sage_const_34 : _sage_const_1p012970 , _sage_const_35 : _sage_const_1p012914 ,
             _sage_const_36 : _sage_const_1p012857 , _sage_const_37 : _sage_const_1p012801 , _sage_const_38 : _sage_const_1p012744 , _sage_const_39 : _sage_const_1p012687 , _sage_const_40 : _sage_const_1p012631 ,
             _sage_const_41 : _sage_const_1p012574 , _sage_const_42 : _sage_const_1p012518 , _sage_const_43 : _sage_const_1p012461 , _sage_const_44 : _sage_const_1p012404 , _sage_const_45 : _sage_const_1p012348 ,
             _sage_const_46 : _sage_const_1p012291 , _sage_const_47 : _sage_const_1p012235 , _sage_const_48 : _sage_const_1p012178 , _sage_const_49 : _sage_const_1p012121 , _sage_const_50 : _sage_const_1p012065 }

    if k != round(k):
        x = k - floor(k)
        d1 = compute_delta(floor(k))
        d2 = compute_delta(floor(k) + _sage_const_1 )
        return x * d2 + (_sage_const_1  - x) * d1

    k = int(k)
    if k < _sage_const_50 :
        return small[k]
    else:
        delta = GH_sv_factor_squared(k)**(_sage_const_1p  / (_sage_const_2p  * k - _sage_const_2p ))
        return delta.n()


def bkzgsa_gso_len(logvol, i, d, beta=None, delta=None):
    if delta is None:
        delta = compute_delta(beta)

    return RR(delta**(d - _sage_const_1  - _sage_const_2  * i) * exp(logvol / d))


rk = [_sage_const_0p789527997160000 , _sage_const_0p780003183804613 , _sage_const_0p750872218594458 , _sage_const_0p706520454592593 , _sage_const_0p696345241018901 , _sage_const_0p660533841808400 , _sage_const_0p626274718790505 , _sage_const_0p581480717333169 , _sage_const_0p553171463433503 , _sage_const_0p520811087419712 , _sage_const_0p487994338534253 , _sage_const_0p459541470573431 , _sage_const_0p414638319529319 , _sage_const_0p392811729940846 , _sage_const_0p339090376264829 , _sage_const_0p306561491936042 , _sage_const_0p276041187709516 , _sage_const_0p236698863270441 , _sage_const_0p196186341673080 , _sage_const_0p161214212092249 , _sage_const_0p110895134828114 , _sage_const_0p0678261623920553 , _sage_const_0p0272807162335610 , -
      _sage_const_0p0234609979600137 , -_sage_const_0p0320527224746912 , -_sage_const_0p0940331032784437 , -_sage_const_0p129109087817554 , -_sage_const_0p176965384290173 , -_sage_const_0p209405754915959 , -_sage_const_0p265867993276493 , -_sage_const_0p299031324494802 , -_sage_const_0p349338597048432 , -_sage_const_0p380428160303508 , -_sage_const_0p427399405474537 , -_sage_const_0p474944677694975 , -_sage_const_0p530140672818150 , -_sage_const_0p561625221138784 , -_sage_const_0p612008793872032 , -_sage_const_0p669011014635905 , -_sage_const_0p713766731570930 , -_sage_const_0p754041787011810 , -_sage_const_0p808609696192079 , -_sage_const_0p859933249032210 , -_sage_const_0p884479963601658 , -_sage_const_0p886666930030433 ]
simBKZ_c = [None] + [rk[-i] - sum(rk[-i:]) / i for i in range(_sage_const_1 , _sage_const_46 )]

pruning_proba = _sage_const_p5 
simBKZ_c += [RR(log(GH_sv_factor_squared(d)) / _sage_const_2p  -
                log(pruning_proba) / d) / log(_sage_const_2p ) for d in range(_sage_const_46 , _sage_const_1500 )]


def simBKZ(l, beta, tours=_sage_const_1 , c=simBKZ_c):

    n = len(l)
    l2 = copy(vector(RR, l))

    for k in range(n - _sage_const_1 ):
        d = min(beta, n - k)
        f = k + d
        logV = sum(l2[k:f])
        lma = logV / d + c[d]

        if lma >= l2[k]:
            continue

        diff = l2[k] - lma
        l2[k] -= diff
        for a in range(k + _sage_const_1 , f):
            l2[a] += diff / (f - k - _sage_const_1 )

    return l2


chisquared_table = {i: None for i in range(_sage_const_1000 )}


for i in range(_sage_const_2049 ):
    chisquared_table[i] = RealDistribution('chisquared', i)


def conditional_chi_squared(d1, d2, lt, l2):
    """
    Probability that a gaussian sample (var=1) of dim d1+d2 has length at most
    lt knowing that the d2 first cordinates have length at most l2
    """
    D1 = chisquared_table[d1].cum_distribution_function
    D2 = chisquared_table[d2].cum_distribution_function
    l2 = RR(l2)

    PE2 = D2(l2)
    # In large dim, we can get underflow leading to NaN
    # When this happens, assume lifting is successfully (underestimating security)
    if PE2 == _sage_const_0 :
        raise ValueError("Numerical underflow in conditional_chi_squared")

    steps = _sage_const_5  * (d1 + d2)

    # Numerical computation of the integral
    proba = _sage_const_0p 
    for i in range(steps)[::-_sage_const_1 ]:
        l2_min = i * l2 / steps
        l2_mid = (i + _sage_const_p5 ) * l2 / steps
        l2_max = (i + _sage_const_1 ) * l2 / steps

        PC2 = (D2(l2_max) - D2(l2_min)) / PE2
        PE1 = D1(lt - l2_mid)

        proba += PC2 * PE1

    return proba


def predict_sign_forge_beta(d, logvol, sver, tours=_sage_const_1 ):
    delta = compute_delta(_sage_const_2 )
    l = [log(bkzgsa_gso_len(logvol, i, d, delta=delta)) / log(_sage_const_2 )
         for i in range(d)]

    if tours == _sage_const_1 :
        betas = range(_sage_const_2 , d)
    else:
        betas = [floor(x/tours) for x in range(_sage_const_1 +floor(_sage_const_2 *tours), ceil(d*tours))]

    for beta in betas:
        l = simBKZ(l, beta, _sage_const_1 )
        if _sage_const_2 **l[_sage_const_0 ] <= sver * sqrt(d):
            return beta
    raise ValueError('not solvable')


def predict_beta_and_prev_sd(d, logvol, tours=_sage_const_1 , ignore_lift_proba=False,
                             lift_union_bound=False, number_targets=_sage_const_1 ,
                             verbose=False):
    """
    Computes the beta value for given dimension and volumes, as well as the
    standard deviation of the first basis vector just before detection of
    a short vector.

    It is assumed that the instance has been normalized and sphericized,
    i.e. that the covariance matrices of the secret is the identity
    :d: integer
    :vol: float
    """

    remaining_proba = _sage_const_1p 
    average_beta = _sage_const_0p 
    average_sd = _sage_const_0p 
    cumulated_proba = _sage_const_0p 

    delta = compute_delta(_sage_const_2 )
    l = [log(bkzgsa_gso_len(logvol, i, d, delta=delta)) / log(_sage_const_2p )
         for i in range(d)]

    if tours == _sage_const_1 :
        betas = range(_sage_const_2 , d)
    else:
        betas = [floor(x/tours) for x in range(_sage_const_1 +floor(_sage_const_2 *tours), ceil(d*tours))]

    for beta in betas:
        current_sd = RR((_sage_const_2 **l[_sage_const_0 ])/sqrt(d))
        l = simBKZ(l, beta, _sage_const_1 )
        proba = _sage_const_1p 
        i = d - beta
        proba *= chisquared_table[beta].cum_distribution_function(
            _sage_const_2 **(_sage_const_2  * l[i]))

        if not ignore_lift_proba:
            for j in range(_sage_const_2 , int(d / beta + _sage_const_1 )):
                i = d - j * (beta - _sage_const_1 ) - _sage_const_1 
                xt = _sage_const_2 **(_sage_const_2  * l[i])
                if j > _sage_const_1 :
                    if not lift_union_bound:
                        x2 = _sage_const_2 **(_sage_const_2  * l[i + (beta - _sage_const_1 )])
                        d2 = d - i + (beta - _sage_const_1 )
                        proba *= conditional_chi_squared(beta - _sage_const_1 , d2, xt, x2)
                    else:
                        proba = min(proba, chisquared_table[d-i].cum_distribution_function(xt))

        for t in range(number_targets):
            average_beta += beta * remaining_proba * proba
            average_sd += current_sd * remaining_proba * proba
            cumulated_proba += remaining_proba * proba
            remaining_proba *= _sage_const_1p  - proba

        if verbose:
            print("β= %d,\t pr=%.4e, \t cum-pr=%.4e \t rem-pr=%.4e" % (beta, proba, cumulated_proba, remaining_proba))

        if remaining_proba < _sage_const_p001 :
            average_beta += beta * remaining_proba
            break

    if remaining_proba > _sage_const_p01 :
        raise ValueError("This instance may be unsolvable")

    return average_beta, average_sd

